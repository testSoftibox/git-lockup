#!/usr/bin/python

import os, re, sys

# duplicate the functionality of git/transport.c L917 transport_get()

def delegate_to_helper(helper, repo, url):
    prog = "git-remote-"+helper
    print >>sys.stderr, "EXEC", prog, repo, url
    os.execlp(prog, prog, repo, url)
    sys.exit(1)

debug = True
def delegate_to_programs(fetch_args, push_args):
    # we must pretend to be a real remote-helper long enough to find out
    # whether we're pushing or fetching. Then we exec a command and let them
    # take over. The command we run depends upon whether we're pushing or
    # fetching.

    while True:
        command = sys.stdin.readline().strip()
        if debug:
            print >>sys.stderr, "COMMAND=", command
        if command == "capabilities":
            print "*connect"
            print
            sys.stdout.flush()
            continue
        if command.startswith("connect"):
            service = command.split()[1]
            # for fetching, this is "git-upload-pack"
            # for pushing, this is "git-receive-pack"
            if service == "git-upload-pack":
                args = fetch_args
                print >>sys.stderr, "hey, we're fetching"
            elif service == "git-receive-pack":
                args = push_args
                print >>sys.stderr, "hey, we're pushing"
            else:
                print >>sys.stderr, "unhandled connect-mode '%s'" % service
                sys.exit(1)
            if debug:
                print >>sys.stderr, "becoming", args
            print # this means "connection established"
            sys.stdout.flush()
            os.execlp(args[0], *args)
            # that never returns
            print >>sys.stderr, "hey, %s returned" % (args,)
            sys.exit(1) # make it obvious
        print >>sys.stderr, "Unknown command '%s'" % command
        sys.exit(1)

def process(url):
    mo = re.search(r'^([A-Za-z0-9][A-Za-z0-9+.-]*)::(.*)$', url)
    if mo:
        # note: to actually trigger this, the original URL (which must be
        # something like random::stuff) must be replaced with
        # passthrough::random::stuff. It is insufficient to just add
        # "vcs=passthrough", as the random:: prefix overrides vcs=
        helper, url = mo.groups()
        return delegate_to_helper(helper, repo, url)
    elif url.startswith("rsync:"):
        print >>sys.stderr, "cannot handle rsync"
        sys.exit(1)
    elif ( # transport.c L854 is_local
        (not ":" in url)
          or ("/" in url and url.index("/") < url.index(":"))
          or False # has_dos_drive_prefix(url), yeah right
        ):
        return delegate_to_programs(["git-upload-pack", url],
                                    ["git-receive-pack", url])
    else:
        mo = re.search(r'^([A-Za-z0-9][A-Za-z0-9+.-]*)://(.*)$', url)
        if mo:
            # URL-like
            scheme, rest = mo.groups()
            if scheme == "file":
                return delegate_to_programs(["git-upload-pack", rest],
                                            ["git-receive-pack", rest])
            elif scheme == "git":
                where = rest[:rest.index("/")]
                if ":" in where:
                    host,port = where.split(":", 1)
                else:
                    host = where
                    port = "9418"
                # TODO: doesn't work yet, I think the git protocol has an
                # extra message
                return delegate_to_programs(["nc", host, port],
                                            ["nc", host, port])
            elif scheme in ("ssh", "git+ssh", "ssh+git"):
                cmd = ["ssh"]
                ssh, path = rest.split("/", 1)
                if not path.startswith("~"):
                    path = "/"+path
                if ":" in ssh:
                    ssh, port = ssh.split(":")
                    cmd.extend(["-p", port])
                cmd.append(ssh)
                return delegate_to_programs(cmd + ["git-upload-pack", path],
                                            cmd + ["git-receive-pack", path])
            else:
                # unknown scheme, hand full URL to helper
                return delegate_to_helper(scheme, repo, url)
        elif ":" in url:
            # maybe ssh-like?
            host, path = url.split(":")
            return delegate_to_programs(["ssh", host, "git-upload-pack", path],
                                        ["ssh", host, "git-receive-pack", path])


repo, url = sys.argv[1:3]

print >>sys.stderr, "PASSTHROOUGH"
print >>sys.stderr, "repo: %s, url: %s" % (repo, url)

process(url)
