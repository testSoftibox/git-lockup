#!/usr/bin/env python

import sys, os, subprocess

def announce(s):
    print >>sys.stderr, s

def debug(s):
    print >>sys.stderr, s
    return

def run_command(args, cwd=None, stdin="", verbose=False):
    try:
        # remember shell=False, so use git.cmd on windows, not just git
        p = subprocess.Popen(args,
                             stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                             cwd=cwd)
    except EnvironmentError:
        e = sys.exc_info()[1]
        if verbose:
            debug("unable to run %s" % args[0])
            debug(e)
        return None
    stdout = p.communicate(stdin)[0]
    if sys.version >= '3':
        stdout = stdout.decode()
    if p.returncode != 0:
        if verbose:
            debug("unable to run %s (error)" % args[0])
        return None
    return stdout

def get_remote_refs(raw_remote_name):
    # git-ls-remote returns tab-joined "SHA\tNAME", and we want
    # space-separated "SHA NAME"
    tab_text = run_command(["git", "ls-remote", raw_remote_name])
    space_text = "\n".join([" ".join(line.split())
                            for line in tab_text.splitlines()])+"\n"
    return space_text

def run_pre_fetch_hook(git_dir, raw_remote_name, stdin):
    hook = os.path.join(git_dir, "hooks", "post-fetch")
    if os.access(hook, os.X_OK):
        announce("running hook")
        debug("passing %d bytes to stdin" % len(stdin));
        rc = run_command([hook, raw_remote_name], stdin=stdin)
        if rc == None:
            announce("post-fetch hook threw error, aborting fetch")
            sys.exit(1)
        # post-fetch hook is happy, allow transfer
        announce("post-fetch hook is happy")

def update_raw(raw_remote_name):
    debug("FETCH_HEAD contains: %s" % (run_command(["cat", ".git/FETCH_HEAD"]),))
    old_FETCH_HEAD = open(".git/FETCH_HEAD", "rb").read()
    debug("fetching new refs")
    run_command(["git", "fetch", "--no-tags", "--update-head-ok", raw_remote_name])
    debug("fetched refs")
    debug("FETCH_HEAD now contains: %s" % (run_command(["cat", ".git/FETCH_HEAD"]),))
    debug("deleting .git/FETCH_HEAD")
    try:
        os.unlink(".git/FETCH_HEAD")
    except EnvironmentError:
        pass


debug("ARGS=%s" % (sys.argv,))
real_remote_name, temp_url = sys.argv[1:3]
raw_remote_name = temp_url.replace("assure://", "")
git_dir = os.path.abspath(os.environ["GIT_DIR"])
debug(git_dir)

while True:
    command = sys.stdin.readline().strip()
    debug("COMMAND=%s" % command)

    if command == "":
        # we're being told to shut down
        sys.exit(0)

    if command == "capabilities":
        sys.stdout.write("fetch\n") # commands are 'list' and 'fetch'
        sys.stdout.write("\n")
        sys.stdout.flush()
        continue

    if command == "list":
        # all the mid-fetch hook work happens now, before we return the
        # reference list to the "git fetch" driver.
        all_refs_text = get_remote_refs(raw_remote_name)
        debug("all refs: '%s'" % (all_refs_text,))

        # then run the pre-fetch hook, allowing it to judge the raw remote.
        # This will sys.exit(1) if the hook rejects what it sees.
        #run_pre_fetch_hook(git_dir, raw_remote_name, all_refs_text+"\n")

        # now fetch all objects into a separate -raw remote, so that the
        # parent fetch won't need us to provide any actual objects.
        update_raw(raw_remote_name)

        debug("returning full ref list")
        # now return the full reflist
        sys.stdout.write(all_refs_text)
        # abc123.. HEAD
        # abc123.. refs/heads/master
        sys.stdout.write("\n") # terminates the list
        sys.stdout.flush()
        debug("finished returning full ref list")
        continue

    if command.startswith("fetch"):
        announce("Hey, don't fetch, you should already have everything")
        sys.exit(1)

    print >>sys.stderr, "Unknown command '%s'" % command
    sys.exit(1)
