#+STARTUP: hidestars

* Ensure the validity of your git checkouts


* usage
  - this package has a bunch of source code, but only creates a single .py
    output file, "assure"
  - committers should run "assure setup-push" from inside a .git tree
    - it will compile python-ed25519 and install a hook script that runs on
      'git push'
    - then it will ask for a key name (usually the name of the project), and
      create the private key in ~/.git-assure/KEYNAME.signingkey
    - it will store key name (but not the key itself) in an unused .git
      directory. It will also record the public verifying key there.
    - it will also ask for a place to write the user scripts to. This should
      be some sort of "misc/" directory in your source tree. It will write
      three files there: the original "assure" script, the public verifying
      key, and a README.git-assure with install instructions for users. These
      three files should be commited and published in your git repo. You may
      also want to add notes to your top-level developer-oriented README file
      pointing at these instructions.
  - users (i.e. your developers who do 'git clone' and 'git pull', but not
    necessarily 'git push'), should see these instructions, which will tell
    them to run "assure setup-pull"
    - when they run that, it will compile python-ed25119 and install a hook
      script that runs on 'git fetch' and 'git pull'
    - the public verifying key will be copied out of the source tree into an
      unised .git directory. This prevents it from being modified by git
      operations like 'pull' or 'checkout'.


* data storage
** ideally put the signatures in the repo with 'git notes', attached to each
   revision
*** when a committer starts to use this, the new refs/notes/commits branch
    needs to be pushed manually
*** a 'git clone' after that branch is present will pick up the notes
*** but if the 'git clone' was done before the branch appeared, a subsequent
    'git pull' won't
*** so "assure setup-pull" should get them too
*** 'git clone' from a github repo with refs/notes/commits doesn't get them
    - 'git ls-remote' shows them
    - 'git fetch origin refs/notes/commits:refs/notes/commits' works
    - but it doesn't seem sticky: normal 'git fetch' doesn't update it
      - ah, probably since the default in .git/config is fetch =
        +refs/heads/*:refsremotes/origin/*
      - may need to add a +refs/notes/commits:refs/notes/commits during setup
    - I think the same is true for push
*** TODO hm, needs more work. Looks appropriate, but moving them around
    requires some care during setup
** if that doesn't work, put them in a separate github "Gist", and store the
   repo URL of it next to the pubkey


* signature format
** one signature per line
** message body is like "master=633641174a7bf18e49bdef581d31fdfcc603d39e"
** sample: signing.key=unhexlify("7369676e302def04727e9a23d8fa1a66787300df0c6781edde5adbb17c68488c33ee1919447a")
** lines are "assure: BODY SIG KEY", like:
   - assure: master=633641174a7bf18e49bdef581d31fdfcc603d39e sig0-7mul5nbgdghmu4mywgtpjsj3skrxyxcwub7apnunlzcgzyw2awvdcaycfuymvxqvuzijd5hxfxpgeztmjuhvisapcq3aj3utfbk56dq verf0-2gy3ublnkjoeyorb234vkqqajlm5mgej3koepk4hr6aqkmm2wuwq
** 'git notes' has provisions to cleanly merge+dedup line-based notes


* development
** this tree will contain a bunch of source code, and a build step will
   create the one "assure" output file
*** that will be a python program with commands like "install-push" and
    "install-pull"
*** it will contain a ascii-encoded copy of python-ed25119
    - without the 2.5MB known-answer-tests, it's a 65kB .zip, 86kB base64
*** it'll compile that in a tempdir, and install into a quiet .git/ dir
    - .git/ASSURE-TOOLS maybe?
    - the hook script will add it to sys.path before 'import ed25519'
** DEV PLAN:
*** study hooks, identify the right ones
**** "post-commit" for outbound: no parms, cannot affect outcome of git
     commit
**** we really want a "pre-merge", but there isn't one
     - pre-receive only says it runs on the server side
**** "post-merge" (takes a single "is a squash merge" flag)
     - runs after merge, and cannot affect the outcome
     - but it could reset the branch back to an earlier (good) version
     - it also doesn't help us check parentage
       - we need to check that the new rev is a descendant of the old rev
       - which means we must know what the old rev was
**** post-commit isn't run after a pull or merge, only 'git checkout'
**** hm, we could use a proxy, or a magic remote protocol
**** oh, I think post-merge has enough information:
***** we know what HEAD we're on afterwards (say "master")
***** use the reflog to find out what master was beforehand (can't tolerate
      octopus merges)
***** examine master's current revision to identify all its parents
***** one of the parents is master@{1}, so ignore that
***** use git-config to find out what master's upstream branch is
***** compare the other parent against the current value of the upstream
      branch, this identifies a normal merge
***** now do the signature check against that upstream branch value
***** and do the parentage check against our remembered upstream value
***** remember that upstream value for the next time
**** hey, 'git reflog refs/remotes/origin/master'
***** so first, figure out what the upstream branch is
***** then find out what the current value is. If that is a parent of the
      current post-merged HEAD, then this was an upstream pull, so we need
      to check stuff
***** we've remembered some previous value of the upstream as valid. Check
      that the new value of upstream is value and that it is a descendant of
      the remembered value, then update our memory.
**** huh, that's hard stuf
***** so one tool to start with would be just a checker: look at all remote
      branches, check each one (current value is signed, and is a descendant
      of a previously accepted value).
****** we'd prefer to run this during during fetch, just before setting
       refs/heads/remotes/REMOTE/BRANCH to the new value, where we'd like to
       abort the assignment on failure.
****** we could also run it after fetch (but before merge), in which case
       we'd roll back the REMOTE/BRANCH ref to the previously-accepted value
****** we can run this during the existing post-merge hook, and learn about
       historical problems, but if there were any problems, mitigation is
       tricky
****** to help with that, the routine should return (last-accepted,
       current-bad) for each problem branch
***** second routine is to figure out whether the recent merge was affected
****** since the post-merge hook runs immediately after each merge, we can
       use the current branch's reflog to find out its previous value, and
       at the current revision's parents to figure out it's history
****** we might also take advantage of knowing this branch's upstream name
****** we ignore the parent that equals reflog[-1]
****** then there's a set of merge scenarios:
******* lots of holes, especially if the user does a bunch of fetches (but
        not merges, so we don't get control), then merges in some
        intermediate value
******* toughest case is probably:
******** upstream pushes signed values for both branch "master" and branch
         "evil"
******** attacker tries to trick user into getting "evil" when merging from
         master
******** by the time post-merge happens, we've lost information about what
         they were trying to merge from. If they did 'git merge
         origin/evil', then it's fine. If they did 'git merge origin/master'
         and got the evil rev, then that's an attack.
******** parentage tells us which revision was being merged, but not the
         semantics (which branch name was being used)
******** might glean it from the merge comments? ick.
**** probably safer to simulate a fetch-hook by using a separate remote
***** upon install, replace the remote with a special handler, and move the
      original to e.g. "origin-raw"
***** the replacement URL would be like "gitlock::origin-raw"
***** then write a remote-helper for scheme "gitlock" that starts with a
      normal git-fetch of the raw remote, then checks the branch values
      before copying them into the processed one.
***** hm, pushes would need handling too, should just pass-through, but
      update the branch values.
      - git-fetch documents a [url NEWBASE]insteadOf=OLDBASE and
        pushInsteadOf=OLDBASE which can rewrite urls differently for pushes
        and pulls
***** git config set remote.NAME.vcs ASSURE
***** then exec(git-remote-ASSURE, NAME, URL)
***** would be nice if git exposed its handler for git/ssh/rsync protocols
      - transport.c line 917
        - get_refs_via_connect, fetch_refs_via_pack, git_transport_push,
          connect_git, disconnect_git
      - connect.c line 447 git_connect()
****** 'git push' uses 'git-send-pack [[user@]host:]repopath' on the near
       side, and runs git-receive-pack on the far side
****** 'git fetch' uses 'git-upload-pack' on the far side and runs
       'git-fetch-pack [host:]repopath' on the near side
****** if URL happens to be http/https, just exec git-remote-http
******* 'git-remote-http' uses http-fetch.c and http-push.c
****** parse URL, if ssh, exec(ssh host git-receive-pack args..)
******* requires parsing some bits of URL, maybe check for some .git/config
        options (using something other than git-receive-pack, etc)
****** if URL is git:, exec netcat


*** outbound
**** DONE script to create signature to stdout, using system-installed ed25519
**** DONE then add it to a 'git notes'
**** then figure out what .git/config is necessary to push notes
*** inbound
**** DONE script to extract note
**** script to check signature, check parentage
**** attach to hook script
**** figure out .git/config needed to pull notes
     - maybe pull them from the hook script, slightly slower
*** then packaging:
**** change scripts to use PYTHONPATH=.git/private
**** figure out receiver-side installer
**** figure out sender-side installer
**** figure out installer-builder


* replay protection
** if enabled, just assert that the previous value of the branch is an
   ancestor of the new proposed version. Git takes care of the rest.


