#+STARTUP: hidestars

* Ensure the validity of your git checkouts


* usage
  - this package has a bunch of source code, but only creates a single .py
    output file, "assure"
  - committers should run "assure setup-push" from inside a .git tree
    - it will compile python-ed25519 and install a hook script that runs on
      'git push'
    - then it will ask for a key name (usually the name of the project), and
      create the private key in ~/.git-assure/KEYNAME.signingkey
    - it will store key name (but not the key itself) in an unused .git
      directory. It will also record the public verifying key there.
    - it will also ask for a place to write the user scripts to. This should
      be some sort of "misc/" directory in your source tree. It will write
      three files there: the original "assure" script, the public verifying
      key, and a README.git-assure with install instructions for users. These
      three files should be commited and published in your git repo. You may
      also want to add notes to your top-level developer-oriented README file
      pointing at these instructions.
  - users (i.e. your developers who do 'git clone' and 'git pull', but not
    necessarily 'git push'), should see these instructions, which will tell
    them to run "assure setup-pull"
    - when they run that, it will compile python-ed25119 and install a hook
      script that runs on 'git fetch' and 'git pull'
    - the public verifying key will be copied out of the source tree into an
      unised .git directory. This prevents it from being modified by git
      operations like 'pull' or 'checkout'.


* data storage
** ideally put the signatures in the repo with 'git notes', attached to each
   revision
*** when a committer starts to use this, the new refs/notes/commits branch
    needs to be pushed manually
*** a 'git clone' after that branch is present will pick up the notes
*** but if the 'git clone' was done before the branch appeared, a subsequent
    'git pull' won't
*** so "assure setup-pull" should get them too
*** 'git clone' from a github repo with refs/notes/commits doesn't get them
    - 'git ls-remote' shows them
    - 'git fetch origin refs/notes/commits:refs/notes/commits' works
    - but it doesn't seem sticky: normal 'git fetch' doesn't update it
      - ah, probably since the default in .git/config is fetch =
        +refs/heads/*:refsremotes/origin/*
      - may need to add a +refs/notes/commits:refs/notes/commits during setup
    - I think the same is true for push
*** TODO hm, needs more work. Looks appropriate, but moving them around
    requires some care during setup
** if that doesn't work, put them in a separate github "Gist", and store the
   repo URL of it next to the pubkey


* signature format
** one signature per line
** message body is like "master=633641174a7bf18e49bdef581d31fdfcc603d39e"
** sample: signing.key=unhexlify("7369676e302def04727e9a23d8fa1a66787300df0c6781edde5adbb17c68488c33ee1919447a")
** lines are "assure: BODY SIG KEY", like:
   - assure: master=633641174a7bf18e49bdef581d31fdfcc603d39e sig0-7mul5nbgdghmu4mywgtpjsj3skrxyxcwub7apnunlzcgzyw2awvdcaycfuymvxqvuzijd5hxfxpgeztmjuhvisapcq3aj3utfbk56dq verf0-2gy3ublnkjoeyorb234vkqqajlm5mgej3koepk4hr6aqkmm2wuwq
** 'git notes' has provisions to cleanly merge+dedup line-based notes


* development
** this tree will contain a bunch of source code, and a build step will
   create the one "assure" output file
*** that will be a python program with commands like "install-push" and
    "install-pull"
*** it will contain a ascii-encoded copy of python-ed25119
    - without the 2.5MB known-answer-tests, it's a 65kB .zip, 86kB base64
*** it'll compile that in a tempdir, and install into a quiet .git/ dir
    - .git/ASSURE-TOOLS maybe?
    - the hook script will add it to sys.path before 'import ed25519'
** DEV PLAN:
*** study hooks, identify the right ones
**** "post-commit" for outbound: no parms, cannot affect outcome of git
     commit
**** we really want a "pre-merge", but there isn't one
     - pre-receive only says it runs on the server side
**** "post-merge" (takes a single "is a squash merge" flag)
     - runs after merge, and cannot affect the outcome
     - but it could reset the branch back to an earlier (good) version
     - it also doesn't help us check parentage
       - we need to check that the new rev is a descendant of the old rev
       - which means we must know what the old rev was
**** post-commit isn't run after a pull or merge, only 'git checkout'
**** hm, we could use a proxy, or a magic remote protocol
**** oh, I think post-merge has enough information:
***** we know what HEAD we're on afterwards (say "master")
***** use the reflog to find out what master was beforehand (can't tolerate
      octopus merges)
***** examine master's current revision to identify all its parents
***** one of the parents is master@{1}, so ignore that
***** use git-config to find out what master's upstream branch is
***** compare the other parent against the current value of the upstream
      branch, this identifies a normal merge
***** now do the signature check against that upstream branch value
***** and do the parentage check against our remembered upstream value
***** remember that upstream value for the next time
**** hey, 'git reflog refs/remotes/origin/master'
***** so first, figure out what the upstream branch is
***** then find out what the current value is. If that is a parent of the
      current post-merged HEAD, then this was an upstream pull, so we need
      to check stuff
***** we've remembered some previous value of the upstream as valid. Check
      that the new value of upstream is value and that it is a descendant of
      the remembered value, then update our memory.
**** huh, that's hard stuf
***** so one tool to start with would be just a checker: look at all remote
      branches, check each one (current value is signed, and is a descendant
      of a previously accepted value).
****** we'd prefer to run this during during fetch, just before setting
       refs/heads/remotes/REMOTE/BRANCH to the new value, where we'd like to
       abort the assignment on failure.
****** we could also run it after fetch (but before merge), in which case
       we'd roll back the REMOTE/BRANCH ref to the previously-accepted value
****** we can run this during the existing post-merge hook, and learn about
       historical problems, but if there were any problems, mitigation is
       tricky
****** to help with that, the routine should return (last-accepted,
       current-bad) for each problem branch
***** second routine is to figure out whether the recent merge was affected
****** since the post-merge hook runs immediately after each merge, we can
       use the current branch's reflog to find out its previous value, and
       at the current revision's parents to figure out it's history
****** we might also take advantage of knowing this branch's upstream name
****** we ignore the parent that equals reflog[-1]
****** then there's a set of merge scenarios:
******* lots of holes, especially if the user does a bunch of fetches (but
        not merges, so we don't get control), then merges in some
        intermediate value
******* toughest case is probably:
******** upstream pushes signed values for both branch "master" and branch
         "evil"
******** attacker tries to trick user into getting "evil" when merging from
         master
******** by the time post-merge happens, we've lost information about what
         they were trying to merge from. If they did 'git merge
         origin/evil', then it's fine. If they did 'git merge origin/master'
         and got the evil rev, then that's an attack.
******** parentage tells us which revision was being merged, but not the
         semantics (which branch name was being used)
******** might glean it from the merge comments? ick.
**** probably safer to simulate a fetch-hook by using a separate remote
***** upon install, replace the remote with a special handler, and move the
      original to e.g. "origin-raw"
***** the replacement URL would be like "gitlock::origin-raw"
***** then write a remote-helper for scheme "gitlock" that starts with a
      normal git-fetch of the raw remote, then checks the branch values
      before copying them into the processed one.
***** hm, pushes would need handling too, should just pass-through, but
      update the branch values.
      - git-fetch documents a [url NEWBASE]insteadOf=OLDBASE and
        pushInsteadOf=OLDBASE which can rewrite urls differently for pushes
        and pulls
***** would be nice if git exposed its handler for git/ssh/rsync protocols
      - transport.c line 917
        - get_refs_via_connect, fetch_refs_via_pack, git_transport_push,
          connect_git, disconnect_git
      - connect.c line 447 git_connect()
****** 'git push' uses 'git-send-pack [[user@]host:]repopath' on the near
       side, and runs git-receive-pack on the far side
****** 'git fetch' uses 'git-upload-pack' on the far side and runs
       'git-fetch-pack [host:]repopath' on the near side
**** easier special-remote (still a hassle):
***** git config set remote.NAME.vcs ASSURE
***** then exec(git-remote-ASSURE, REMOTENAME, URL)
***** our git-remote-ASSURE starts by doing 'git fetch REMOTENAME-raw', let
      it run to completion
***** then examine all branches in REMOTENAME-raw, check signatures and
      parentage, throw exception (exit with rc=1) upon problems, then the
      real 'git fetch' will report a remote error. Bonus points for getting
      the error message to stderr.
***** then we "just" need to implement the real remote operations
***** easiest is to advertise "connect" capability, then parse URL and
      simulate git's builtin connection handlers
****** if URL happens to be http/https, just exec git-remote-http
******* do this before interpreting any part of the protocol, let
        git-remote-http handle everything
******* 'git-remote-http' uses http-fetch.c and http-push.c
****** else, need to parse URL (ssh/git/file), advertise "connect", wait for
       the connect command to be issued with a 'service' argument, then:
******* if ssh, exec[ssh host git-receive-pack|git-upload-pack (args..?)]
******** maybe check for some .git/config options (using something other than
         git-receive-pack, etc)
******* if git:, exec netcat and maybe send a command name
******** my flappserver handler (git-remote-pb) does this
******* if URL is file:, exec[git-(receive|upload)-pack]
**** ok, my git-remote-passthrough is coming together
***** cases to test:
****** DONE HELPER::rest_of_url
****** rsync:
****** DONE /path/to/local
****** DONE file:///path/to/local
****** TODO git://host/path
       - doesn't work yet, I think the git protocol has an extra message
****** git://host:port/path
****** DONE ssh://host/path
****** DONE ssh://host/~/path
****** DONE ssh://user@host:port/path
****** DONE other ssh synonyms: git+ssh, ssh+git
****** DONE helper://rest
****** DONE host:path
        - luther:/tmp/t.git
****** actual URL values:
	url = /Users/warner/stuff/vc/git/git-assure/t/one
	#url = file:///Users/warner/stuff/vc/git/git-assure/t/one
	#url = luther:/tmp/t.git
        #url = ssh://luther/tmp/t.git
        #url = ssh://luther:22/tmp/t.git
        #url = ssh://warner@luther:22/tmp/t.git
        #url = ssh://luther/~/t.git
        #url = ssh://luther/~warner/t.git
        #url = ssh+git://luther/tmp/t.git
        #url = git+ssh://luther/tmp/t.git
        ##url = git://luther:9418/tmp/t.git
        #url = https://github.com/warner/python-ed25519.git
        #url = passthrough::https://github.com/warner/python-ed25519.git
        vcs = passthrough
**** nov-2012, does git make this any easier now?
***** git-remote-fd lets you set up your remote connection first, attach it
      to some spare fds, then run 'git fetch fd::12,13' to bypass (manually
      control) the connection setup phase. It then speaks the git protocol
      over those fds (or a single bidirectional one).
***** git-remote-ext is similar, but takes a command to spawn that will
      create the remote connection (it then speaks the git protocol over
      stdin/stdout of the child process).
***** git-remote-helpers is a python library that provides local-repo
      commands (list-references, get object, etc) to build remotes that
      manipulate local repos more easily
***** no post-fetch hook yet.
***** to simulate a post-fetch hook:
****** do real fetch to some parallel/related remote
****** run post-fetch hook (which might raise an error)
****** copy refs from the parallel remote to the real one
***** hm. maybe 3 remotes: A,B,C. "A" is the real upstream, so when the merge
      finally happens, it will pull from A. The URL for A points to our
      special helper, somehow. When the helper gets control, it first resets
      all of B's refs to whatever is in C. Then it does a normal 'git fetch
      B', which grabs everything without checking, then runs the post-fetch
      hook. If the hook passes, it copies the B refs to C, then copies the B
      refs to A, then exits with success.
***** that allows the upstream to be reset without persistently breaking the
      local copy (C will always be good). Oh, A is enough for that.
***** two remotes: real, temp. 'real.url' points at the special helper,
      'temp.url' points at the real remote repo (during setup, just copy
      real.url into temp.url [for push only]). The magic remote-type in
      real.url gives control to the helper. The helper overwrites temp's refs
      with those from 'real', then does 'git fetch temp', then runs the
      post-fetch hook, then maybe copies the new refs from temp back to real.
      Maybe even create 'temp' each time, then delete it afterwards. Problem:
      the top-level git-fetch has to be negated somehow, turned into a NOP.
***** oh, better: special helper does: copy real refs to temp, 'git fetch
      temp', run post-fetch hook, then uses the "connect" capability and
      execs git-upload-pack pointing at the local repo. Modify the
      read.refspec to pull from refs/remotes/temp/* instead of refs/heads/* .
      Then the top-level 'git fetch' will do the temp-to-real ref copy, and
      we don't have to figure out how to NOP it.
****** all fetches will fetch all branches, unless there's a way to glean the
       'git fetch' arguments in the remote-helper and pass them into the 'git
       fetch temp' command. Most likely outcome is limitations on the
       original 'git fetch' command will be ignored.


*** outbound
**** DONE script to create signature to stdout, using system-installed ed25519
**** DONE then add it to a 'git notes'
**** then figure out what .git/config is necessary to push notes
*** inbound
**** DONE script to extract note
**** script to check signature, check parentage
**** attach to hook script
**** figure out .git/config needed to pull notes
     - maybe pull them from the hook script, slightly slower
*** then packaging:
**** change scripts to use PYTHONPATH=.git/private
**** figure out receiver-side installer
**** figure out sender-side installer
**** figure out installer-builder


* replay protection
** if enabled, just assert that the previous value of the branch is an
   ancestor of the new proposed version. Git takes care of the rest.


