
* Ensure the validity of your git checkouts


* usage
  - this package has a bunch of source code, but only creates a single .py
    output file, "assure"
  - committers should run "assure setup-push" from inside a .git tree
    - it will compile python-ed25519 and install a hook script that runs on
      'git push'
    - then it will ask for a key name (usually the name of the project), and
      create the private key in ~/.git-assure/KEYNAME.signingkey
    - it will store key name (but not the key itself) in an unused .git
      directory. It will also record the public verifying key there.
    - it will also ask for a place to write the user scripts to. This should
      be some sort of "misc/" directory in your source tree. It will write
      three files there: the original "assure" script, the public verifying
      key, and a README.git-assure with install instructions for users. These
      three files should be commited and published in your git repo. You may
      also want to add notes to your top-level developer-oriented README file
      pointing at these instructions.
  - users (i.e. your developers who do 'git clone' and 'git pull', but not
    necessarily 'git push'), should see these instructions, which will tell
    them to run "assure setup-pull"
    - when they run that, it will compile python-ed25119 and install a hook
      script that runs on 'git fetch' and 'git pull'
    - the public verifying key will be copied out of the source tree into an
      unised .git directory. This prevents it from being modified by git
      operations like 'pull' or 'checkout'.


* data storage
** ideally put the signatures in the repo with 'git notes', attached to each
   revision
*** when a committer starts to use this, the new refs/notes/commits branch
    needs to be pushed manually
*** a 'git clone' after that branch is present will pick up the notes
*** but if the 'git clone' was done before the branch appeared, a subsequent
    'git pull' won't
*** so "assure setup-pull" should get them too
*** 'git clone' from a github repo with refs/notes/commits doesn't get them
    - 'git ls-remote' shows them
    - 'git fetch origin refs/notes/commits:refs/notes/commits' works
    - but it doesn't seem sticky: normal 'git fetch' doesn't update it
      - ah, probably since the default in .git/config is fetch =
        +refs/heads/*:refsremotes/origin/*
      - may need to add a +refs/notes/commits:refs/notes/commits during setup
    - I think the same is true for push
*** TODO hm, needs more work. Looks appropriate, but moving them around
    requires some care during setup
** if that doesn't work, put them in a separate github "Gist", and store the
   repo URL of it next to the pubkey


* signature format
** one signature per line
** message body is like "master=633641174a7bf18e49bdef581d31fdfcc603d39e"
** sample: signing.key=unhexlify("7369676e302def04727e9a23d8fa1a66787300df0c6781edde5adbb17c68488c33ee1919447a")
** lines are "assure: BODY SIG KEY", like:
   - assure: master=633641174a7bf18e49bdef581d31fdfcc603d39e sig0-7mul5nbgdghmu4mywgtpjsj3skrxyxcwub7apnunlzcgzyw2awvdcaycfuymvxqvuzijd5hxfxpgeztmjuhvisapcq3aj3utfbk56dq verf0-2gy3ublnkjoeyorb234vkqqajlm5mgej3koepk4hr6aqkmm2wuwq
** 'git notes' has provisions to cleanly merge+dedup line-based notes


* development
** this tree will contain a bunch of source code, and a build step will
   create the one "assure" output file
*** that will be a python program with commands like "install-push" and
    "install-pull"
*** it will contain a ascii-encoded copy of python-ed25119
    - without the 2.5MB known-answer-tests, it's a 65kB .zip, 86kB base64
*** it'll compile that in a tempdir, and install into a quiet .git/ dir
    - .git/ASSURE-TOOLS maybe?
    - the hook script will add it to sys.path before 'import ed25519'
*** DEV PLAN:
**** study hooks, identify the right ones
***** "post-commit" for outbound: no parms, cannot affect outcome of git
      commit
***** we really want a "pre-merge", but there isn't one
      - pre-receive only says it runs on the server side
***** "post-merge" (takes a single "is a squash merge" flag)
      - runs after merge, and cannot affect the outcome
      - but it could reset the branch back to an earlier (good) version
**** outbound
***** script to create signature to stdout, using system-installed ed25519
***** then add it to a 'git notes'
***** then figure out what .git/config is necessary to push notes
**** inbound
***** script to extract note
***** script to check signature, check parentage
***** attach to hook script
***** figure out .git/config needed to pull notes
      - maybe pull them from the hook script, slightly slower
**** then packaging:
***** change scripts to use PYTHONPATH=.git/private
***** figure out receiver-side installer
***** figure out sender-side installer
***** figure out installer-builder


* replay protection
** if enabled, just assert that the previous value of the branch is an
   ancestor of the new proposed version. Git takes care of the rest.


