#!/usr/bin/env python

# this is installed as a "mid-fetch" hook

import os, sys, subprocess

def debug(s):
    print >>sys.stderr, s
    return

def run_command(args, cwd=None, stdin="", eat_stderr=False, verbose=False):
    try:
        # remember shell=False, so use git.cmd on windows, not just git
        stderr = None
        if eat_stderr:
            stderr = subprocess.PIPE
        p = subprocess.Popen(args,
                             stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                             stderr=stderr,
                             cwd=cwd)
    except EnvironmentError:
        e = sys.exc_info()[1]
        if verbose:
            debug("unable to run %s" % args[0])
            debug(e)
        return None
    stdout = p.communicate(stdin)[0]
    if sys.version >= '3':
        stdout = stdout.decode()
    if p.returncode != 0:
        if verbose:
            debug("unable to run %s (error)" % args[0])
        return None
    return stdout

remote_name = sys.argv[1]
debug("in hook, working on %s" % (remote_name,))
url = run_command(["git", "config", "remote.%s.pushurl" % remote_name]).strip()
url = url.replace("assure::", "")

# these are all of the new upstream refs. We're probably only interested in
# refs/heads/*, but we'll see everything they've got.
all_refs = {}
for line in sys.stdin.readlines():
    #debug("hook readline got: %s" % line)
    if not line.strip():
        break
    sha, name = line.split()
    all_refs[name] = sha
debug("got %d refs" % len(all_refs))

# these are the branches we're configured to care about
keys = {}
out = run_command(["git", "config", "--get-all",
                   "remote.%s.assure" % remote_name])
for line in out.splitlines():
    key, _, branch = line.strip().split()
    if "/" not in branch:
        branch = "refs/heads/"+branch
    keys[branch] = key

# update our list of signatures. We use both the local copy and the current
# upstream.
out = run_command(["git", "rev-parse", "refs/notes/commits"],
                          eat_stderr=True)
if out is None:
    print >>sys.stderr, "Could not find local refs/notes/commits."
    print >>sys.stderr, "Maybe you need to pull some."
    local_notes_revid = None
else:
    local_notes_revid = out.strip()

out = run_command(["git", "fetch", "--no-tags", url,
                                    "refs/notes/commits"], eat_stderr=False)
if out is None:
    print >>sys.stderr, "Could not find refs/notes/commits in the upstream repo."
    print >>sys.stderr, "Maybe you (or someone else) needs to push some signatures to it?"
    upstream_notes_revid = None
else:
    upstream_notes_revid = run_command(["git", "rev-parse", "FETCH_HEAD"]).strip()
    os.unlink(".git/FETCH_HEAD")

def get_all_signatures(revid):
    print >>sys.stderr, "COMMAND", ["git", "show",
                                    "%s:%s" % (upstream_notes_revid, revid)]
    remote_lines = run_command(["git", "show",
                                "%s:%s" % (upstream_notes_revid, revid)],
                               eat_stderr=True) or ""
    local_lines =  run_command(["git", "show",
                                "%s:%s" % (local_notes_revid, revid)],
                               eat_stderr=True) or ""
    lines = set()
    lines.update(remote_lines.splitlines())
    lines.update(local_lines.splitlines())
    return [line.replace("assure: ", "")
            for line in lines
            if line.startswith("assure:")]

import ed25519

for branch,key in keys.items():
    if branch not in all_refs:
        # tolerate missing branches. This allows assure= lines to be set up
        # in the config file before the named branches are actually
        # published. I *think* this is safe and useful, but could be
        # convinced otherwise.
        continue
    proposed_branch_revid = all_refs[branch]
    found_good_signature = False
    signatures = get_all_signatures(proposed_branch_revid)
    print >>sys.stderr, "SIGS for", branch, proposed_branch_revid, signatures
    for sigline in signatures:
        print >>sys.stderr, "SIG", sigline
        s_body, s_sig, s_key = sigline.split()
        if s_key != key:
            debug("wrong key")
            continue # signed by a key we don't recognize
        if s_body != ("%s=%s" % (branch, proposed_branch_revid)):
            debug("wrong branch or wrong revid")
            continue # talking about the wrong branch or revid
        vk = ed25519.VerifyingKey(key, prefix="vk0-", encoding="base32")
        try:
            vk.verify(s_sig, s_body, prefix="sig0-", encoding="base32")
            found_good_signature = True
            debug("good signature found for branch %s (rev %s)" % (branch, proposed_branch_revid))
            break
        except ed25519.BadSignatureError:
            debug("bad signature")
            continue

    if not found_good_signature:
        print >>sys.stderr, "no valid signature found for branch %s (rev %s)" % (branch, proposed_branch_revid)
        sys.exit(1)

if 0:
    print >>sys.stderr, "HOOK SMASH!"
    sys.exit(1)
